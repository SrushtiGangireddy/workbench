# coding: utf-8

"""
    AllOfUs Workbench API

    The API for the AllOfUs workbench.

    OpenAPI spec version: 0.1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient


class DataBrowserApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_analyses(self, **kwargs):
        """
        Gets list of analysis definitions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_analyses(async=True)
        >>> result = thread.get()

        :param async bool
        :return: AnalysisListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_analyses_with_http_info(**kwargs)
        else:
            (data) = self.get_analyses_with_http_info(**kwargs)
            return data

    def get_analyses_with_http_info(self, **kwargs):
        """
        Gets list of analysis definitions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_analyses_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: AnalysisListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_analyses" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/v1/databrowser/analyses', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnalysisListResponse',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_analysis_results(self, analysis_id, **kwargs):
        """
        Gets results for an analysis id and stratum
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_analysis_results(analysis_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int analysis_id: analysis_id (required)
        :param str stratum_1: stratum 1
        :param str stratum_2: stratum 2
        :return: AnalysisResultListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_analysis_results_with_http_info(analysis_id, **kwargs)
        else:
            (data) = self.get_analysis_results_with_http_info(analysis_id, **kwargs)
            return data

    def get_analysis_results_with_http_info(self, analysis_id, **kwargs):
        """
        Gets results for an analysis id and stratum
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_analysis_results_with_http_info(analysis_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int analysis_id: analysis_id (required)
        :param str stratum_1: stratum 1
        :param str stratum_2: stratum 2
        :return: AnalysisResultListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['analysis_id', 'stratum_1', 'stratum_2']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_analysis_results" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'analysis_id' is set
        if ('analysis_id' not in params) or (params['analysis_id'] is None):
            raise ValueError("Missing the required parameter `analysis_id` when calling `get_analysis_results`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'analysis_id' in params:
            query_params.append(('analysis_id', params['analysis_id']))
        if 'stratum_1' in params:
            query_params.append(('stratum_1', params['stratum_1']))
        if 'stratum_2' in params:
            query_params.append(('stratum_2', params['stratum_2']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/v1/databrowser/analysis-results', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnalysisResultListResponse',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_child_concepts(self, concept_id, **kwargs):
        """
        Get children of the given concept
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_child_concepts(concept_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concept_id: concept id to get maps to concepts (required)
        :return: ConceptListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_child_concepts_with_http_info(concept_id, **kwargs)
        else:
            (data) = self.get_child_concepts_with_http_info(concept_id, **kwargs)
            return data

    def get_child_concepts_with_http_info(self, concept_id, **kwargs):
        """
        Get children of the given concept
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_child_concepts_with_http_info(concept_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concept_id: concept id to get maps to concepts (required)
        :return: ConceptListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concept_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_child_concepts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'concept_id' is set
        if ('concept_id' not in params) or (params['concept_id'] is None):
            raise ValueError("Missing the required parameter `concept_id` when calling `get_child_concepts`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'concept_id' in params:
            query_params.append(('concept_id', params['concept_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/v1/databrowser/child-concepts', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ConceptListResponse',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_concept_count(self, concept_id, **kwargs):
        """
        Gets count for concept
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_concept_count(concept_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str concept_id: concept id to get count for (required)
        :return: AnalysisResultListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_concept_count_with_http_info(concept_id, **kwargs)
        else:
            (data) = self.get_concept_count_with_http_info(concept_id, **kwargs)
            return data

    def get_concept_count_with_http_info(self, concept_id, **kwargs):
        """
        Gets count for concept
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_concept_count_with_http_info(concept_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str concept_id: concept id to get count for (required)
        :return: AnalysisResultListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concept_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_concept_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'concept_id' is set
        if ('concept_id' not in params) or (params['concept_id'] is None):
            raise ValueError("Missing the required parameter `concept_id` when calling `get_concept_count`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'concept_id' in params:
            query_params.append(('concept_id', params['concept_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/v1/databrowser/concept-count', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnalysisResultListResponse',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_concept_count_by_age(self, concept_id, **kwargs):
        """
        Gets counts for concept by age
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_concept_count_by_age(concept_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str concept_id: concept id to get count for (required)
        :return: AnalysisResultListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_concept_count_by_age_with_http_info(concept_id, **kwargs)
        else:
            (data) = self.get_concept_count_by_age_with_http_info(concept_id, **kwargs)
            return data

    def get_concept_count_by_age_with_http_info(self, concept_id, **kwargs):
        """
        Gets counts for concept by age
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_concept_count_by_age_with_http_info(concept_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str concept_id: concept id to get count for (required)
        :return: AnalysisResultListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concept_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_concept_count_by_age" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'concept_id' is set
        if ('concept_id' not in params) or (params['concept_id'] is None):
            raise ValueError("Missing the required parameter `concept_id` when calling `get_concept_count_by_age`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'concept_id' in params:
            query_params.append(('concept_id', params['concept_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/v1/databrowser/concept-count-by-age', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnalysisResultListResponse',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_concept_count_by_gender(self, concept_id, **kwargs):
        """
        Gets counts for concept by gender
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_concept_count_by_gender(concept_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str concept_id: concept id to get count for (required)
        :return: AnalysisResultListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_concept_count_by_gender_with_http_info(concept_id, **kwargs)
        else:
            (data) = self.get_concept_count_by_gender_with_http_info(concept_id, **kwargs)
            return data

    def get_concept_count_by_gender_with_http_info(self, concept_id, **kwargs):
        """
        Gets counts for concept by gender
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_concept_count_by_gender_with_http_info(concept_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str concept_id: concept id to get count for (required)
        :return: AnalysisResultListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concept_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_concept_count_by_gender" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'concept_id' is set
        if ('concept_id' not in params) or (params['concept_id'] is None):
            raise ValueError("Missing the required parameter `concept_id` when calling `get_concept_count_by_gender`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'concept_id' in params:
            query_params.append(('concept_id', params['concept_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/v1/databrowser/concept-count-by-gender', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnalysisResultListResponse',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_concepts_search(self, **kwargs):
        """
        Searches for concepts in concept table with search string and filters
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_concepts_search(async=True)
        >>> result = thread.get()

        :param async bool
        :param str concept_name: concept name search string
        :param str standard_concept: standard concept filter
        :param str concept_code: concept code  filter
        :param str vocabulary_id: vocabulary id filter
        :param str domain_id: vocabulary id filter
        :return: ConceptListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_concepts_search_with_http_info(**kwargs)
        else:
            (data) = self.get_concepts_search_with_http_info(**kwargs)
            return data

    def get_concepts_search_with_http_info(self, **kwargs):
        """
        Searches for concepts in concept table with search string and filters
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_concepts_search_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str concept_name: concept name search string
        :param str standard_concept: standard concept filter
        :param str concept_code: concept code  filter
        :param str vocabulary_id: vocabulary id filter
        :param str domain_id: vocabulary id filter
        :return: ConceptListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concept_name', 'standard_concept', 'concept_code', 'vocabulary_id', 'domain_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_concepts_search" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'concept_name' in params:
            query_params.append(('concept_name', params['concept_name']))
        if 'standard_concept' in params:
            query_params.append(('standard_concept', params['standard_concept']))
        if 'concept_code' in params:
            query_params.append(('concept_code', params['concept_code']))
        if 'vocabulary_id' in params:
            query_params.append(('vocabulary_id', params['vocabulary_id']))
        if 'domain_id' in params:
            query_params.append(('domain_id', params['domain_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/v1/databrowser/search-concepts', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ConceptListResponse',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_db_domains(self, **kwargs):
        """
        Gets list of analysis definitions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_db_domains(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DbDomainListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_db_domains_with_http_info(**kwargs)
        else:
            (data) = self.get_db_domains_with_http_info(**kwargs)
            return data

    def get_db_domains_with_http_info(self, **kwargs):
        """
        Gets list of analysis definitions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_db_domains_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: DbDomainListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_db_domains" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/v1/databrowser/db-domains', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DbDomainListResponse',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_parent_concepts(self, concept_id, **kwargs):
        """
        Gets parent concepts for the given concept
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_parent_concepts(concept_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concept_id: concept id to get maps to concepts (required)
        :return: ConceptListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_parent_concepts_with_http_info(concept_id, **kwargs)
        else:
            (data) = self.get_parent_concepts_with_http_info(concept_id, **kwargs)
            return data

    def get_parent_concepts_with_http_info(self, concept_id, **kwargs):
        """
        Gets parent concepts for the given concept
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_parent_concepts_with_http_info(concept_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concept_id: concept id to get maps to concepts (required)
        :return: ConceptListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concept_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_parent_concepts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'concept_id' is set
        if ('concept_id' not in params) or (params['concept_id'] is None):
            raise ValueError("Missing the required parameter `concept_id` when calling `get_parent_concepts`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'concept_id' in params:
            query_params.append(('concept_id', params['concept_id']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/v1/databrowser/parent-concepts', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ConceptListResponse',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_participant_count(self, **kwargs):
        """
        Gets results for an analysis id and stratum
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_participant_count(async=True)
        >>> result = thread.get()

        :param async bool
        :return: AnalysisResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_participant_count_with_http_info(**kwargs)
        else:
            (data) = self.get_participant_count_with_http_info(**kwargs)
            return data

    def get_participant_count_with_http_info(self, **kwargs):
        """
        Gets results for an analysis id and stratum
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_participant_count_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: AnalysisResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_participant_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/v1/databrowser/participant-count', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='AnalysisResult',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
